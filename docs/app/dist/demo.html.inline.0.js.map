{
  "version": 3,
  "sources": ["../../../build/_snowpack/pkg/uuid.js", "../../../build/app/dist/swm.js"],
  "sourcesContent": ["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\nvar REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport { v4 };\n", "import { v4 } from \"../../_snowpack/pkg/uuid.js\";\n\n// Sanity checking functions.\n\nconst expectedMessageType = Object.prototype.toString.call({});\n\nexport function checkMessageType(message) {\n  const type = Object.prototype.toString.call(message);\n  if (type !== expectedMessageType) {\n    console.error(\n      `expected a message of type \"${expectedMessageType}\", got \"${type}\"!`\n    );\n  }\n}\n\nexport function checkClientStructure(client) {\n  if (!client) {\n    console.error('A SMART client is required to use this library!');\n  }\n  else if (!client.tokenResponse) {\n    console.error('The provided SMART client has no tokenResponse attribute!');\n  }\n  if (!client.tokenResponse.smart_web_messaging_handle) {\n    console.error(\n      'SMART client is missing a smart_web_messaging_handle launch attribute!'\n    );\n  }\n  if (!client.tokenResponse.smart_web_messaging_origin) {\n    console.error(\n      'SMART client is missing a smart_web_messaging_origin launch attribute!'\n    );\n  }\n}\n\n// Helper to enable the HTML5 postMessage API in the caller's context.\n\nexport function enablePostMessage(targetOrigin, callback) {\n  const messageEventHandler = function (e) {\n    if (e.origin === targetOrigin && e.data) {\n      checkMessageType(e.data);\n      callback(e.data);\n    }\n  }\n  window.addEventListener('message', messageEventHandler, false);\n}\n\n// TODO: include the SWM IG version number here somewhere?\n// TODO: include links in error messages to the relevant IG sections...\n// TODO: create docstrings for all functions.\n\nfunction getMessage(messageType, client) {\n  if (!messageType) {\n    console.error('Messages SHALL specify a messageType');\n  }\n  checkClientStructure(client);\n  return {\n    'messageType': messageType,\n    'messagingHandle': client.tokenResponse.smart_web_messaging_handle || '',\n    'messageId': v4(),\n    'payload': {}\n  }\n}\n\nfunction getResponse(responseToMessageId) {\n  if (!responseToMessageId) {\n    console.error('A response MUST have a responseToMessageId present.');\n  }\n  return {\n    'responseToMessageId': responseToMessageId,\n    'messageId': v4(),\n    'payload': {},\n  }\n}\n\nexport function getHandshakeMessage(client) {\n  return getMessage('status.handshake', client);\n}\n\nexport function getHandshakeResponse(responseToMessageId) {\n  return getResponse(responseToMessageId);\n}\n\nexport function getUiDoneMessage(client) {\n  return getMessage('ui.done', client);\n}\n\nfunction getUiResponse(responseToMessageId, status, statusDetailText) {\n  return {\n    ...getResponse(responseToMessageId),\n    'payload': {\n      'status': status || '',\n      'statusDetail': {\n        'text': statusDetailText || '',\n      }\n    }\n  }\n}\n\nexport function getUiDoneResponse(responseToMessageId, status, statusDetailText) {\n  return getUiResponse(responseToMessageId, status, statusDetailText);\n}\n\nexport function getUiLaunchActivityMessage(client, activityType, activityParameters) {\n  return {\n    ...getMessage('ui.launchActivity', client),\n    'payload': {\n      'activityType': activityType,\n      'activityParameters': activityParameters,\n    }\n  }\n}\n\nexport function getUiLaunchActivityResponse(responseToMessageId, status, statusDetailText) {\n  return getUiResponse(responseToMessageId, status, statusDetailText);  \n}\n\nfunction getScratchpadResponse(responseToMessageId, status, location, outcome) {\n  const payload = { 'status': status };\n  // Add the optional scratchpad response fields.\n  if (location) {\n    payload['location'] = location;\n  }\n  if (outcome) {\n    payload['outcome'] = outcome;\n  }\n  return {\n    ...getResponse(responseToMessageId),\n    'payload': payload,\n  }\n}\n\nexport function getScratchpadCreateMessage(client, resource) {\n  return {\n    ...getMessage('scratchpad.create', client),\n    'payload': {\n      'resource': resource,\n    }\n  }\n}\n\nexport function getScratchpadCreateResponse(responseToMessageId, status, location, outcome) {\n  return getScratchpadResponse(responseToMessageId, status, location, outcome);\n}\n\nexport function getScratchpadUpdateMessage(client, resource, location) {\n  return {\n    ...getMessage('scratchpad.update', client),\n    'payload': {\n      'location': location,\n      'resource': resource,\n    }\n  }\n}\n\nexport function getScratchpadUpdateResponse(responseToMessageId, status, location, outcome) {\n  return getScratchpadResponse(responseToMessageId, status, location, outcome);\n}\n\nexport function getScratchpadDeleteMessage(client, location) {\n  return {\n    ...getMessage('scratchpad.delete', client),\n    'payload': {\n      'location': location,\n    }\n  }\n}\n\nexport function getScratchpadDeleteResponse(responseToMessageId, status, outcome) {\n  return getScratchpadResponse(responseToMessageId, status, null, outcome);\n}\n\nexport function sendMessage(client, message) {\n  checkMessageType(message);\n  checkClientStructure(client);\n  const targetOrigin = client.tokenResponse.smart_web_messaging_origin;\n  if (targetOrigin !== new URL(targetOrigin).origin) {\n    console.error(`Invalid message origin: '${targetOrigin}'`);\n  }\n\n  if (window.parent) {\n    window.parent.postMessage(message, targetOrigin);\n  } else if (window.opener) {\n    window.opener.postMessage(message, targetOrigin);\n  } else {\n    console.error('Unable to send message - no receiver!');\n  }\n}\n\nexport function sendResponse(appWindow, message, appOrigin) {\n  checkMessageType(message);\n  if (appOrigin !== new URL(appOrigin).origin) {\n    console.error(`Invalid response origin: '${appOrigin}'`);\n  }\n  appWindow.postMessage(message, appOrigin);\n}\n"],
  "mappings": ";AAIA,IAAI,QAAQ,IAAI,WAAW;AA2B3B,IAAI,YAAY;AAEhB,SAAS,IAAI,GAAG,IAAI,KAAK,EAAE,GAAG;AAC5B,YAAU,KAAM,KAAI,KAAO,SAAS,IAAI,OAAO;AAAA;;;AC9BjD,IAAM,sBAAsB,OAAO,UAAU,SAAS,KAAK;",
  "names": []
}
